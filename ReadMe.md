# Kafka Workshop Part 3: Schema Registry with Protobuf

In this exercise you will create a class library containing `.proto` files to define Protobuf schemas from which C# classes will be generated by both Consumer and Producer applications. This is a convenient way to share schema defintions among multiple projects.

In the **Protos** folder you will create multiple versions of the `HelloReply` schema with properties that are added or subtracted in a way that is both forward and backwards compatible. There is a also a version that violates Protobuf schema evolution rules which will result in a serialization error when the Producer attempts to write it to Kafka.

> **Note**: Here is a blog post explaining the design of  the event stream processing framework: https://blog.tonysneed.com/2020/06/25/event-stream-processing-micro-framework-apache-kafka/.

### Prerequisites

1. Install [Docker Desktop](https://docs.docker.com/desktop/).
   - You will need at least 8 GB of available memory.
2. Open a terminal at the project root and run `docker-compose up --build -d`.
   - To check the running containers run `docker-compose ps`.
   - To bring down the containers run `docker-compose down`.
3. Open a browser to http://localhost:9021/.
   - Verify the cluster is healthy. (This may take a few minutes.)

> **Note**: Switch to the `after` branch to view the completed solution: `git checkout after`

## Proto Library

1. Create a **greet.v1.proto** file in **Protos** folder.
   - First delete **Placeholder.txt** from the **Protos** folder.
   - Note the `csharp_namespace` option which specifies the namespace in which the `HelloReply` class will be placed.
    ```protobuf
    syntax = "proto3";

    option csharp_namespace = "Protos.v1";

    // The response message containing the greetings.
    message HelloReply {
      string message = 1;
    }
    ```

## Producer

1. Add Google.Protobuf, Grpc.Core, Grpc.Tools packages, schema registry Protobuf.
    ```bash
    dotnet add package Google.Protobuf
    dotnet add package Grpc.Core
    dotnet add package Grpc.Tools
    dotnet add pacakge Confluent.SchemaRegistry.Serdes.Protobuf
    ```
2. Update .csproj to include .proto files from the **ProtoLibrary** project.
    ```xml
    <ItemGroup>
      <Protobuf Include="../ProtoLibrary/Protos/**/*.proto" />
    </ItemGroup>
    ```
   - Build the **Producer** project, then inspect contents of the **obj/debug/netcoreapp3.1** folder for the presence of a **GreetV1.cs** file.
   - Note the generated `HelloReply` class in the `Protos.v1` namespace.
3. Uncomment line 86 in **Program.cs** to call `Run_Producer` with `Protos.v1.HelloReply`.
    ```csharp
    await Run_Producer<Protos.v1.HelloReply>(producerOptions.Brokers, topic, producerOptions.SchemaRegistryUrl, key, text);
    ```
4. Update the `Run_Producer` method to create `SchemaRegistryConfig` and `CachedSchemaRegistryClient`. Then set value Protobuf serializer using schema registry.
    ```csharp
    // Create SchemaRegistryConfig
    var schemaRegistryConfig = new SchemaRegistryConfig { Url = schemaRegistryUrl };

    // Create CachedSchemaRegistryClient
    using (var schemaRegistry = new CachedSchemaRegistryClient(schemaRegistryConfig))
    using (var producer = new ProducerBuilder<int, TValue>(config)
        // Set value Protobuf serializer using schema registry
        .SetValueSerializer(new ProtobufSerializer<TValue>(schemaRegistry))
        .Build())
    ```
5. Configure partial classes, so that versions of the `HelloReply` class can implement different interfaces.
   - Inspect the **IHelloReply.cs** file in the **Partials** folder.
   - Note that the `IHelloReply` interface has been defined and that is has a `Message` property.
   - Note the `IHelloReply_1` inherits from `IHelloReply`.
   - Open the **HelloReply.cs** file and uncomment `HelloReply` class in the `Protos.v1` namespace.
    ```csharp
    namespace Protos.v1
    {
        public partial class HelloReply : IHelloReply_1
        {
        }
    }
    ```
6. Update the `CreateMessageValue` method by uncommenting lines 148-151, which set the `Message` property.
    ```csharp
    if (val is IHelloReply val1)
    {
        val1.Message = msg;
    };
    ```
7. Update the `PrintMessageValue` method by commenting lines 178-181, which set the `Message` property.
    ```csharp
    if (val is Protos.v1.HelloReply val1)
    {
        msg = val1.Message;
    }
    ```
8. Run the **Producer** to write an event stream.
   - Set breakpoints on line 110 in the `Run_Producer` method.
   - Press **F5** to start the debugger in Visual Studio.
   - Press **Enter** to accept the `hello-reply` topic (or enter a new topic).
   - Enter `1` for the version number.
   - Create a message by entering: `1 Hello World`
   - Press **Ctrl+C** to terminate the Producer.

## Consumer

1. Add Google.Protobuf, Grpc.Core, Grpc.Tools packages, schema registry Protobuf.
    ```bash
    dotnet add package Google.Protobuf
    dotnet add package Grpc.Core
    dotnet add package Grpc.Tools
    dotnet add pacakge Confluent.SchemaRegistry.Serdes.Protobuf
    ```
2. Update .csproj to include .proto files from the **ProtoLibrary** project.
    ```xml
    <ItemGroup>
      <Protobuf Include="../ProtoLibrary/Protos/**/*.proto" />
    </ItemGroup>
    ```
   - Build the **Consumer** project, then inspect contents of the **obj/debug/netcoreapp3.1** folder for the presence of a **GreetV1.cs** file.
   - Note the generated `HelloReply` class in the `Protos.v1` namespace.
3. Uncomment line 58 in **Program.cs** to call `Run_Consumer` with `Protos.v1.HelloReply`.
    ```csharp
    Run_Consumer<Protos.v1.HelloReply>(consumerOptions.Brokers, topics, cts.Token);
    ```
4. Update `Run_Consumer` to uncomment line 102 in order to set the value Protobuf deserializer.
    ```csharp
    .SetValueDeserializer(new ProtobufDeserializer<TValue>().AsSyncOverAsync())
    ```
5. Update the `PrintConsumeResult` method to uncomment lines 158-161 to get the `Message` property.
    ```csharp
    if (consumeResult.Message.Value is Protos.v1.HelloReply val1)
    {
        msg = val1.Message;
    }
    ```
6. Run the **Consumer** to write an event stream.
   - Set a breakpoint in the `Run_Producer` method.
   - Press **F5** to start the debugger in Visual Studio.
   - Press **Enter** to accept the `hello-reply` topic (or enter a new topic).
   - Enter `1` for the version number.
   - Press **Ctrl+C** to terminate the Producer.

## Schema Evolution

The purpose of the Confluent Schema Registry is to allow for schema evolution for a specific topic based on compatibility rules.
- Compatible schemas are automatically registered when a message is produced.
- Incompatible schemas are not allowed to be registered, because a serialization error is thrown when attempting to produce a message using a schema that breaks compatibilty with the prior schema.
- A new topic will need to be created to support a schema that is incompatible with a prior version.

> **Note**: The rules for Protobuf backward compatibility are derived from the Protobuf language specification.

> **Protobuf Compatibility Rules**:
> - Fields can be **added**. All fields in Protobuf are optional, by default. If you specify defaults, these will be used for backward compatibility.
> - Fields can be **removed**. A field number can be reused by a new field of the same type. A field number cannot be reused by a new field of a different type.
> - Types int32, uint32, int64, uint64 and bool types are compatible (can be swapped in the same field).
> - Types sint32 and sint64 are compatible (can be swapped in the same field).
> - Types string and bytes are compatible (can be swapped in the same field).
> - Types fixed32 and sfixed32 are compatible (can be swapped in the same field).
> - Types fixed64 and sfixed64 are compatible (can be swapped in the same field).
> - Type enum is compatible with int32, uint32, int64, and uint64 (can be swapped in the same field).
> - Changing a single value into a member of a new oneof is compatible.

1. View registered schemas.
    - Get the schema for version 1 by navigating to the following in a browser.
    ```bash
    http://localhost:8081/subjects/hello-reply-value/versions/1 | json_pp
    ```
   - You should see the following output.
    ```bash
    {
       "schemaType" : "PROTOBUF",
       "id" : 1,
       "schema" : "syntax = \"proto3\";\npackage greet;\n\nmessage HelloReply {\n  string message = 1;\n}\n",
       "version" : 1,
       "subject" : "hello-reply-value"
    }
    ```
2. Create a new version of greet proto in **ProtoLibrary**.
   - Copy **greet.v1.proto** to **Protos** folder, rename to greet.v2.proto.
   - Change `csharp_namespace` to `Protos.v2`.
   - Import `google/protobuf/wrappers.proto`.
   - Add `temperatureF` field.
     - When compiled this will generate a nullable int.

    ```protobuf
    syntax = "proto3";

    option csharp_namespace = "Protos.v2";

    import "google/protobuf/wrappers.proto";

    // The response message containing the greetings.
    message HelloReply {
      string message = 1;
      google.protobuf.Int32Value temperatureF = 2;
    }
    ```
3. Update the Producer and Consumer to use version 2 of the HelloReply schema.
   - Build the Producer to generate classes from the added proto files.
   - In the Producer uncomment `IHelloReply_2` in **IHelloReply.cs**.
   - Uncomment `Protos.v2` in **HelloReply.cs**.
   - Update `CreateMessageValue` to uncomment code for `IHelloReply_2`.
   - Update `PrintMessageValue` to uncomment code for `Protos.v2.HelloReply`.
   - Uncomment `case 2` in `Main` in the Producer.
   - Build the Consumer to generate classes from the added proto files.
   - Update the `PrintConsumeResult` method to uncomment `Protos.v2.HelloReply` code.
   - Uncomment `case 2` in `Main` in the Consumer.
4. Because we are only adding a field to the proto file, consumer will be able to process both versions.
   - Run the Producer.
     - Enter schema versions 1 and 2 when prompted.
   - Run the Consumer, specifying schema version 1.
     - Notice that the `temperatureF` field in the second message is omitted.
   - Run the Consumer again, specifying schema version 2.
     - Notice this time that `temperatureF` is included in the second message.
5. Add **greet.v3.proto** to **ProtoLibrary**.
    ```protobuf
    syntax = "proto3";

    option csharp_namespace = "Protos.v3";

    import "google/protobuf/wrappers.proto";
    import "google/protobuf/timestamp.proto";

    // The response message containing the greetings.
    message HelloReply {
      string message = 1;
      google.protobuf.Int32Value temperatureF = 2;
      google.protobuf.Timestamp dateTimeStamp = 3;
    }
    ```
   - Update Producer and Consumer as in #3 above if needed.
   - Run the Producer.
     - Enter schema versions 1, 2 and 3 when prompted.
   - Run the Consumer, specifying schema version 1.
   - Run the Consumer again, specifying schema version 2.
   - Run the Consumer again, specifying schema version 3.
      - Notice that new fields are included with newer versions.
6. Add **greet.v4.proto** to **ProtoLibrary**.
    ```protobuf
    syntax = "proto3";

    option csharp_namespace = "Protos.v4";

    import "google/protobuf/timestamp.proto";

    // The response message containing the greetings.
    message HelloReply {
      string message = 1;
      // Keep same field number as v3
      google.protobuf.Timestamp dateTimeStamp = 3;
    }
    ```
   - Update Producer and Consumer as in #3 above if needed.
   - Run the Producer.
     - Enter schema versions 1, 2, 3 and 4 when prompted.
   - Run the Consumer, specifying schema version 1.
   - Run the Consumer again, specifying schema version 2.
   - Run the Consumer again, specifying schema version 3.
   - Run the Consumer again, specifying schema version 4.
      - Notice that dropped fields are omitted with older versions.
7. Add **greet.v5.proto** to **ProtoLibrary**.
    ```protobuf
    syntax = "proto3";

    option csharp_namespace = "Protos.v5";

    // The response message containing the greetings.
    message HelloReply {
      string message = 1;
      string dateTimeStamp = 3; // Change from Timestamp to string
    }
    ```
     - Change `dateTimeStamp` from `Timestamp` to `string`.
     - Update Producer and Consumer as in #3 above if needed.
     - Run the Producer, specifying version 5.
       - Run the Consumer with version 5.
       - Notice that the `dateTimeStamp` is set and read properly.
     - Run the Producer, specifying versions 4 then 5.
       - Notice the **serialization error** due to the schema change.